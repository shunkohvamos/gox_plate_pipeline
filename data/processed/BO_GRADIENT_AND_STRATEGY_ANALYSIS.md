# BO グラデーション問題と修正方針 — 計算ロジックからの整理

コードはまだ変更せず、**どこが間違っているか計算のロジックから詰め、修正方針と BO ロジックの見直し案**をまとめる。

---

## 1. 前提の確認（貼り付けた調査結果について）

> ベイズ最適化でハマる/ハマらないを決める主因は「獲得関数」より **(1)目的関数の作り方** と **(2)ラウンド差・測定ノイズの扱い**。  
> 「anchor corrected FoG→FoG」「inter-round calibration を消す」「NMRで実組成を確認」へ舵を切っているのは、まさにそこがボトルネックだと見抜いている動き。

→ **同意。** 図の「グラデーションがおかしい」は、**可視化のインデックス/座標の取り違え**と、**目的関数・ノイズの設計**は別レイヤーとして分けて扱う。

- **可視化の誤り**: 計算ロジック（グリッド・座標・Z の対応）のバグ → 本ドキュメント §2–3 で特定。
- **目的関数・ノイズ**: 貼り付けた案（AUC/分位点、Round 階層、複製・基準点の組み込みなど）→ §5–6 で方針として整理。

---

## 2. xy 図（2x2 Mean/Std/EI/UCB）— 計算ロジックの整理

### 2.1 設計空間の定義（コードと一致）

- **x** = BMA/(BMA+MTAC)  
- **y** = (BMA+MTAC)（= 1−MPC の意味で、比ではなく和）  
- 実装: `_xy_from_frac`: `y = frac_BMA + frac_MTAC`, `x = frac_BMA / (frac_BMA + frac_MTAC)`（0除算時 0.5）。  
→ 定義は一貫している。

### 2.2 グリッドと `model.predict` の対応

- `X1, X2 = np.meshgrid(x_grid, y_grid)`（デフォルト `indexing='xy'`）  
  - `X1[i,j] = x_grid[j]`, `X2[i,j] = y_grid[i]`  
  - つまり **配列 (i, j) = (y のインデックス, x のインデックス)**。

- 現状の「predict 用」グリッド:  
  `grid = np.column_stack([X1.T.ravel(), X2.T.ravel()])`  
  - `(X1.T)[i,j] = x_grid[i]`, `(X2.T)[i,j] = y_grid[j]`  
  - `ravel` は行優先 → `grid[k]` の k は `k = i*n_grid + j` のとき  
    `grid[k] = (x_grid[i], y_grid[j])`  
  - つまり **x が遅い・y が速い**（k=0..n-1 で x 固定、y が 0..n-1 と変化）。

- したがって  
  `mu = model.predict(grid)` → `mu.reshape((n_grid, n_grid))` では  
  **Z[i,j] = mu[i*n_grid + j] = 点 (x_grid[i], y_grid[j]) での予測値**  
  → **Z の第1軸 = x インデックス、第2軸 = y インデックス**。

### 2.3 matplotlib `pcolormesh` の約束

- **第1インデックス = 縦軸（画面の y）**  
- **第2インデックス = 横軸（画面の x）**  
- つまり「配列の (i, j) = (縦, 横)」であり、**ラベルで言う x を横にしたいなら、配列上は (y_idx, x_idx) で渡す必要がある**。

### 2.4 どこがずれているか

- **正しくしたい対応**:  
  - 画面の横軸 = x、縦軸 = y。  
  - したがって **Z_plot[y_idx, x_idx] = 点 (x_grid[x_idx], y_grid[y_idx]) の値** である必要がある。  
  - いま **Z[i,j] = 点 (x_grid[i], y_grid[j])** なので、  
    **Z_plot[y_idx, x_idx] = Z[x_idx, y_idx] = (Z.T)[y_idx, x_idx]** とすべき。

- **座標**:  
  - 同じ (y_idx, x_idx) の位置に描くべき座標は **(x_grid[x_idx], y_grid[y_idx])**。  
  - `meshgrid` のまま使うと `(X1, X2)` で `(X1[i,j], X2[i,j]) = (x_grid[j], y_grid[i])` なので、  
    **配列 (i, j) = (y_idx, x_idx)** として使えば、  
    (X1, X2) は「横=x, 縦=y」の座標として正しい。

- **誤りの形**:  
  - もし **(X1.T, X2.T)** と **Z（転置なし）** で描いていた場合、  
    - (X1.T)[i,j]=x_grid[i], (X2.T)[i,j]=y_grid[j] → 配列 (i,j) が (x_idx, y_idx) に対応し、  
    - 画面では第1軸が縦・第2軸が横なので、**縦=x・横=y** になってしまう。  
  - その結果、**本来 (x,y) の 2 次元で滑らかに変化する GP の勾配が、見た目上は「主に横方向の縞」**のように見える（一方の軸だけが効いているように見える）。

**結論（xy）**:  
- **原因**: 描画時の「配列の (行, 列)」と「(x, y)」の対応の取り違え。  
- **修正方針**:  
  - predict 用グリッドと `Z[i,j] = (x_grid[i], y_grid[j])` の解釈はそのままでよい。  
  - 描画時は **座標に (X1, X2)、値に Z.T** を使い、**pcolormesh の (第1軸, 第2軸) = (y_idx, x_idx)** になるようにする。  
- 生データの分布範囲が狭くても、この「軸の取り違え」は独立したバグであり、「分布が狭いから壊れる」種類のものではない。

---

## 3. 三角図（ternary）— 計算ロジックの整理

### 3.1 座標と値の対応

- 三角座標: `_ternary_xy_from_frac(mpc, bma, mtac)`  
  - `tx = bma + 0.5*mpc`, `ty = mpc * sqrt(3)/2`  
  - 頂点: (0,0)=MTAC, (1,0)=BMA, (0.5, √3/2)=MPC。定義は標準的で一貫している。

- 候補 `cand`:  
  - `_generate_simplex_grid(step, min_component)` で **mpc 外側・bma 内側**のループで行を追加。  
  - 同じ `cand` に `_xy_from_frac` で (x, y) を追加し、`model.predict(cand[["x","y"]])` で `pred_log_fog_mean` 等を付与。  
  - したがって **cand の行順と (frac_MPC, frac_BMA, frac_MTAC) および (tx, ty), pred_* はすべて同一行で対応している**。  
  - 三角図では `tx, ty = _ternary_xy_from_frac(mpc, bma, mtac)`, `z = cand[value_col]` なので、**(tx[i], ty[i]) と z[i] は必ず同じ候補点**。  
→ **三角図については「(tx, ty) と z のインデックスの食い違い」はない。**

### 3.2 三角図でグラデーションが「正しくない」と感じる要因（候補）

計算の対応は正しいので、見た目がおかしく見える要因は別にある。

1. **離散レベル（levels）**  
   - `levels = np.linspace(vmin, vmax, 22)` の 22 本の等高線で塗り分け。  
   - レベル数が少ないと「帯状」に見え、滑らかなグラデーションには見えない可能性がある。

2. **Delaunay 三角分割の性質**  
   - 候補は simplex 上で等間隔ではなく、(mpc, bma) のグリッドを (tx, ty) に写しただけなので、** (tx, ty) 空間では点の配置が均一でない**。  
   - 端や辺付近で細長い三角形ができると、**線形補間の向きが不自然**になり、勾配の見え方が歪む可能性がある。

3. **データ範囲と外挿**  
   - 観測が三角の一部にしかない場合、GP はその外側で外挿する。  
   - 外挿領域では不確実性が大きく、平均が平坦になったり、length scale の影響で「縞っぽく」見えることはあり得る。  
   - ただし「分布が狭いから壊れる」のではなく、**「分布が狭いときでも、外挿域をどう表示するか（マスクするか・不確実性を重ねるか）」を設計する**のが筋。

4. **三角図と xy 図の「勾配の向き」の違い**  
   - GP は (x, y) 空間で学習している。  
   - 三角図は (tx, ty) = (bma+0.5*mpc, mpc*√3/2) なので、**(x,y) の勾配を (tx,ty) に写すと向きが変わる**。  
   - これは座標変換の結果でありバグではないが、「xy では滑らかに見えるのに三角では方向が違って見える」という感覚とは整合しうる。

**結論（三角）**:  
- **数値的には (tx, ty) と z の対応は正しい。** 短絡的に「xy と同じ転置を三角にも当てる」必要はない（当てるべき対応関係が三角にはない）。  
- グラデーションを「きれい」にするには:  
  - levels を増やす、または連続カラースケールに近づける（tricontourf のオプションや levels 数）。  
  - 必要なら三角の「外挿域」をマスクする、あるいは不確実性を別パネルで示す。  
- 「生データの分布が狭いと壊れる」のではなく、「分布が狭いときの表示ポリシー」を決める設計にする。

---

## 4. 生データの分布範囲と「壊れるコード」について

- **「そんな程度で壊れるコードはだめ」** という指摘はその通り。  
- 今回の xy の不具合は **「分布が狭いから」ではなく「グリッドと描画のインデックス対応の取り違え」** が原因。  
- 三角図は **対応関係は正しい** が、**レベル数・三角分割・外挿表示** で見た目が不自然になる余地がある。  
- 方針として:  
  - データが三角の一部にしかなくても、**候補点は simplex 全体で評価してよい** が、  
  - **外挿域をどう扱うか**（マスク／別色／不確実性表示）を明示し、  
  - **levels や補間方法は「データの有無に依存しすぎない」** ようにする（例: vmin/vmax を観測範囲でクリップするなど、オプションで持つ）。

---

## 5. log FoG にしていることが「悪い」か

- **目的関数を log(FoG) にする**こと自体は、多くの BO/GP では妥当。  
  - FoG は正値でスケールが広いため、**log 空間で GP を張る**と安定しやすい。  
  - 貼り付けた調査でも「目的関数の作り方」が効くと言っており、**「単一時点の FoG」か「AUC/分位点」か**が論点であり、**log を取ることそのものは否定されていない**。  
- 注意点:  
  - **「log 空間の平均」と「元空間の平均」は違う**。  
  - 現在のコードは `pred_fog_mean = exp(mu + 0.5*std^2)` などで元空間の期待値も出しており、その扱いは妥当。  
- **「グラデーションが縞になる」原因は log ではなく、§2 の xy の軸対応と、§3 の三角の levels/補間・外挿表示にある。**

---

## 6. 貼り付けた調査結果の整理と、BO ロジックの更新方針

以下、貼り付けた内容を要約しつつ、今の実装をどうアップデートするかの方針を整理する。

### 6.1 目的関数（ここが一番効く）

- **A. 最終時点（例: 60 min）**: 実用寄りだがばらつきに弱い。  
- **B. 時間積分（AUC 等）**: ノイズに強く、0 min は別目的（保持）にするとよい。  
- **C. ワーストケース／下側分位点**: 安定寄りの設計向き。  

**方針案**:  
- 現状の「log FoG（ラウンド補正済み）」を **いつ・どう畳むか** をオプション化する。  
  - 例: 単一時点の平均 → そのまま現状に近い。  
  - 例: **AUC（0–60 min の積分）や下側分位点** を bo_learning に列として追加し、目的変数を選べるようにする。  
- 「EI で上位 24 本」の単純運用は、再現性・ラウンド差で崩れやすいという指摘と一致。**目的関数の選択肢を増やす**ことが第一歩。

### 6.2 ノイズ・ラウンドの扱い（inter-round をやめるなら必須）

- **D. Round をランダム効果に入れた階層モデル**  
- **E. 入力依存ノイズ（ヘテロスケダスティック）＋ Noisy EI / qNEI**  

**方針案**:  
- 現状の `apply_round_anchor_correction` を「オフ」にしたとき、**Round を説明変数またはランダム効果として GP に入れる**オプションを検討する。  
- 複製測定を明示的に入れてノイズを学習する設計（下記 F）と組み合わせる。

### 6.3 バッチ 24 本の内訳（探索・再現性の両立）

- **F. 固定ルール例**: 8 本 exploit / 8 本 explore / 4 本 複製 / 4 本 基準点。  
- 「複製を BO の一部として配る」ことで、ノイズ構造を学習し、EI の暴れを抑える。

**方針案**:  
- `n_suggestions` を「内訳」に分解する設定を導入する（例: n_exploit, n_explore, n_replicate, n_anchor）。  
- 複製は **同一組成を複数ウェル** に割り当て、学習データに明示的に含める。

### 6.4 その他（入力の不確かさ・多目的・multi-fidelity）

- **G. errors-in-variables**: feed で提案し、学習は「推定された組成＋誤差」で行う。NMR 実測と組み合わせる想定。  
- **H. 多目的（Pareto / qEHVI）**: 耐熱＋0 min 活性＋合成成功確率など。  
- **I. multi-fidelity**: 軽い代理測定で候補を絞り、重い本試験で確定。

これらは **次のフェーズ** として、目的関数・ノイズ・バッチ設計の見直しの後に検討するのが現実的。

---

## 7. 修正の進め方（まとめ）

### 7.1 可視化（グラデーション）の修正

| 対象 | 原因 | 修正方針 |
|------|------|----------|
| **xy 2x2** | グリッドと pcolormesh の (行,列) と (x,y) の対応の取り違え | 描画時に **(X1, X2)** と **Z.T** を使う（§2 の通り）。グリッド生成と reshape の解釈は現状のままでよい。 |
| **三角図** | (tx,ty) と z の対応は正しい。見た目は levels・三角分割・外挿域の表示に依存 | levels の増加や連続に近い表示の検討。必要なら外挿域のマスク／不確実性表示。短絡的な「転置」は不要。 |

### 7.2 BO ロジックのアップデート（優先度の目安）

1. **目的関数の選択肢**  
   - 現状: 実質「ラウンド補正した log FoG の平均」を最大化。  
   - 追加案: AUC や下側分位点を bo_learning に持ち、目的列を選べるようにする。

2. **ノイズ・ラウンド**  
   - anchor 補正オフ時: Round をモデルに組み込む（階層 or 入力依存ノイズ）。  
   - 複製をバッチに含め、学習データでノイズを推定。

3. **バッチ設計**  
   - exploit / explore / 複製 / 基準点 の内訳を設定で持つ。

### 7.3 採用する「別のロジック」の候補

- **獲得関数**: 現状 EI + UCB の 2 本立てで可。ノイズを明示するなら **qNEI / Noisy EI** が自然。  
- **目的**: **AUC または下側分位点** を第一候補にし、0 min 活性は制約化。  
- **モデル**: Round 階層 or ヘテロスケダスティックをオプションで。  
- **バッチ**: 24 本を「8+8+4+4」のように固定配分するテンプレートを採用する。

---

## 8. 次の一手

1. **まず可視化**: xy は §2 の通り (X1, X2) + Z.T に統一。三角は levels/表示の調整。  
2. **目的関数**: bo_learning に AUC や分位点列を用意する処理を追加し、目的列を選べるようにする。  
3. **ノイズ・バッチ**: 複製と基準点を BO の仕様に組み込み、設定で内訳を指定できるようにする。  

貼り付けた「目的関数・ノイズ・バッチ設計が効く」という結論は、このコードベースにもそのまま当てはまる。図のグラデーションは **計算の対応関係の修正** で直し、**BO の「勝ち筋」は目的関数とノイズ・バッチの設計で詰める**、という二段構えが妥当。
