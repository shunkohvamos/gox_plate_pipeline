# (BMA, MTAC)座標系のデメリット整理

## 1. 可視化面での不便さ

### 1.1 xy_2x2パネル（2Dヒートマップ）でのMPCの見え方

**現在の(x, y)座標系**:
- **y軸** = 1 - MPC に直接対応
- 図を見ただけで「このyの値ならMPCはこれくらい」と直感的にわかる
- 例: y=0.2 → MPC=0.8, y=0.5 → MPC=0.5

**(BMA, MTAC)座標系**:
- MPC = 1 - BMA - MTAC なので、MPCの量は**等高線を引かないとわからない**
- 2Dヒートマップ上で「この点のMPCはどれくらいか」を一目で判断できない
- MPCの等高線を引く必要がある（追加の実装が必要）

**影響**:
- xy_2x2パネル（Mean/Std/EI/UCBの2Dヒートマップ）を見たときに、MPCの量が直感的にわからない
- 「MPCが高い領域」「MPCが低い領域」を素早く識別できない

### 1.2 Ternary mapは問題なし

- Ternary mapは既に `(frac_MPC, frac_BMA, frac_MTAC)` から直接描画している
- 可視化コードは変更不要
- MPCの量は頂点からの距離で直感的にわかる

---

## 2. 解釈性の問題

### 2.1 MPCが主要な設計変数の場合

**現在の(x, y)座標系**:
- y軸が直接「1-MPC」に対応しているので、MPCの影響を直接評価できる
- length_scale_y が小さい = MPC方向に強く依存、という解釈が直感的

**(BMA, MTAC)座標系**:
- MPCは「1 - BMA - MTAC」で間接的にしか表現されない
- MPCの影響を評価するには、BMAとMTACのlength_scaleを組み合わせて解釈する必要がある
- 解釈がやや複雑になる

### 2.2 物理的な意味の直感性

**現在の(x, y)座標系**:
- x = BMA/MTAC比（同じ非MPC量での比率）
- y = 非MPC量 = 1 - MPC
- 物理的な意味が明確

**(BMA, MTAC)座標系**:
- BMAとMTACは直接的な物理量だが、MPCは間接的
- 「MPCを変えたい」という意図を直接的に表現できない

---

## 3. 既存コードとの互換性

### 3.1 既存の可視化コード

- **Ternary map**: 変更不要（既に `(frac_MPC, frac_BMA, frac_MTAC)` から描画）
- **xy_2x2パネル**: 変更が必要（現在は `(x, y)` 空間で描画）

### 3.2 既存のデータ構造

- 学習データには既に `x, y` 列がある
- `(BMA, MTAC)` 座標系にすると、`x, y` 列の意味が変わる（後方互換性の問題）
- または、`x, y` 列を残して、GPの入力だけ `(BMA, MTAC)` にする（二重管理）

---

## 4. ユーザーの直感的な理解

### 4.1 学習曲線・診断図との一貫性

- ユーザーが「MPCを変えるとどうなるか」を考えるとき、y軸を見れば直感的にわかる
- `(BMA, MTAC)` 座標系では、MPCの変化を直接見ることができない

### 4.2 実験設計との対応

- 実験では「MPCを0.8から0.6に変える」という設計が自然
- `(BMA, MTAC)` 座標系では、「BMA+MTACを0.2から0.4に変える」という表現になる
- やや不自然

---

## 5. 実装面での課題

### 5.1 距離計算の複雑さ

**現在の(x, y)座標系**:
- ユーザーが「MPCを変えるとどうなるか」を考えるとき、y軸を見れば直感的にわかる
- `(BMA, MTAC)` 座標系では、MPCの変化を直接見ることができない

**実装の複雑さ**:
- `(BMA, MTAC)` 空間は制約 `BMA + MTAC ≤ 1` がある
- 距離計算も制約内で行う必要がある（現在の実装では既に対応済みだが、確認が必要）

### 5.2 デバッグ・診断の難しさ

- `(x, y)` 座標系では、y軸を見ればMPCの量がわかるので、デバッグが容易
- `(BMA, MTAC)` 座標系では、MPCを計算しないとわからないので、デバッグがやや面倒

---

## 6. まとめ：デメリットの重要度

### 高重要度（採用を阻害する可能性）

1. **xy_2x2パネルでのMPCの見え方**: 図を見ただけでMPCがわからない
2. **解釈性の問題**: MPCが主要な設計変数の場合、影響を直接評価できない

### 中重要度（実装で対応可能）

3. **既存コードとの互換性**: 可視化コードの変更が必要
4. **ユーザーの直感的な理解**: 実験設計との対応がやや不自然

### 低重要度（実装で対応可能）

5. **実装面での課題**: 距離計算やデバッグの複雑さ

---

## 7. 推奨される対応

### オプション1: (BMA, MTAC)座標系 + MPC等高線の追加

- GPの入力: `(BMA, MTAC)`
- xy_2x2パネルにMPCの等高線を追加
- メリット: 距離感が自然、MPCも可視化できる
- デメリット: 実装がやや複雑

### オプション2: 現在の(x, y)座標系を維持 + カーネル調整

- GPの入力: `(x, y)` のまま
- ARDカーネルで `length_scale_x` を `y` の関数にする
- 例: `length_scale_x(y) = base_scale * (1 + alpha / (y + epsilon))`
- メリット: 既存コードの変更が最小限、MPCの見え方は維持
- デメリット: カーネル調整の実装が必要

### オプション3: ハイブリッド（可視化用とGP用を分離）

- 可視化: `(x, y)` または ternary map（変更なし）
- GPの入力: `(BMA, MTAC)`
- メリット: 距離感が自然、可視化は既存のまま
- デメリット: 二重管理、実装がやや複雑

---

## 8. 結論

**最大のデメリット**: xy_2x2パネル（2Dヒートマップ）を見たときに、MPCの量が直感的にわからない。

**推奨**: 
- もしxy_2x2パネルが重要で、MPCの量を直感的に見たい場合は、**現在の(x, y)座標系を維持 + カーネル調整（オプション2）**を推奨
- もしternary mapが主で、xy_2x2パネルは補助的な場合は、**(BMA, MTAC)座標系 + MPC等高線の追加（オプション1）**も検討可能
